\lstset{style=fsharpstyle}

\section{Используемые технологии} 
\label{sec:practice:technology_used}

\subsection{Язык программирования PHP}
\label{sub:practice:php_overview}
PHP (Hypertext Preprocessor - «PHP: препроцессор гипертекста»; первоначально Personal Home Page Tools - «Инструменты для создания персональных веб-страниц») - скриптовый язык общего назначения, интенсивно применяемый для разработки веб-приложений. В настоящее время поддерживается подавляющим большинством хостинг-провайдеров и является одним из лидеров среди языков, применяющихся для создания динамических веб-сайтов.

PHP может все. Главная область применения PHP - написание скриптов, работающих на стороне сервера; таким образом, PHP способен выполнять все то, что выполняет любая другая программа CGI, например, обрабатывать данные форм, генерировать динамические страницы или отсылать и принимать cookies. Но PHP способен выполнять намного больше.

PHP доступен для большинства операционных систем, включая Linux, многие модификации Unix (такие как HP-UX, Solaris и OpenBSD), Microsoft Windows, Mac OS X, RISC OS, и многие другие. Также в PHP включена поддержка большинства современных веб-серверов, таких как Apache, IIS и многих других. В принципе, подойдет любой веб-сервер, способный использовать бинарный файл FastCGI PHP, например, lighttpd или nginx. PHP может работать в качестве модуля или функционировать в качестве процессора CGI.

Таким образом, выбирая PHP, вы получаете свободу выбора операционной системы и веб-сервера. Более того, у вас появляется выбор между использованием процедурного или объектно-ориентированного программирования (ООП) или же их сочетания.

PHP способен генерировать не только HTML. Доступно формирование изображений, файлов PDF и даже роликов Flash (с использованием libswf и Ming), создаваемых «на лету». PHP также способен генерировать любые текстовые данные, такие, как XHTML и другие XML-файлы. PHP может осуществлять автоматическую генерацию таких файлов и сохранять их в файловой системе вашего сервера вместо того, чтобы отдавать клиенту, организуя, таким образом, серверный кэш для вашего динамического контента.

Одним из значительных преимуществ PHP является поддержка широкого круга баз данных. Создать скрипт, использующий базы данных, - невероятно просто. Можно воспользоваться расширением, специфичным для отдельной базы данных (таким как mysql) или использовать уровень абстракции от базы данных, такой как PDO, или подсоединиться к любой базе данных, поддерживающей Открытый Стандарт Соединения Баз Данных (ODBC), с помощью одноименного расширения ODBC. Для других баз данных, таких как CouchDB, можно воспользоваться cURL или сокетами.

PHP также поддерживает «общение» с другими сервисами через такие протоколы, как LDAP, IMAP, SNMP, NNTP, POP3, HTTP, COM (на платформах Windows) и многих других. Кроме того, вы получаете возможность работать с сетевыми сокетами напрямую. PHP поддерживает стандарт обмена сложными структурами данных WDDX практически между всеми языками веб-программирования. Обращая внимание на взаимодействие между различными языками, следует упомянуть о поддержке объектов Java и возможности их использования в качестве объектов PHP.

PHP имеет много возможностей по обработке текста, включая регулярные выражения Perl (PCRE) и много других расширений и инструментов для обработки и доступа к XML документам. В PHP обработка XML-документов стандартизирована и происходит на базе мощной библиотеки libxml2, расширив возможности обработки XML добавлением новых расширений SimpleXML, XMLReader и XMLWriter.

\subsubsection{Область применения. }
\label{sub:practice:whereis_php}
В области веб-программирования, в частности серверной части, PHP - один из популярных сценарных языков (наряду с JSP, Perl и языками, используемыми в ASP.NET).

Популярность в области построения веб-сайтов определяется наличием большого набора встроенных средств для разработки веб-приложений. 

Основные из них:
\begin{itemize}
  \item автоматическое извлечение POST и GET-параметров, а также переменных окружения веб-сервера в предопределённые массивы;
  \item взаимодействие с большим количеством различных систем управления базами данных;
  \item автоматизированная отправка HTTP-заголовков;
  \item работа с HTTP-авторизацией;
  \item работа с локальными и удалёнными файлами, сокетами;
  \item обработка файлов, загружаемых на сервер;
  \item работа с cookies и сессиями;
\end{itemize}

В настоящее время PHP используется сотнями тысяч разработчиков. Согласно рейтингу корпорации TIOBE, базирующемся на данных поисковых систем, в мае 2016 года PHP находился на 6 месте среди языков программирования. К крупнейшим сайтам, использующим PHP, относятся Facebook, Wikipedia и др.



\subsubsection{Элементарные типы PHP. }
\label{sub:practice:types_php}

РНР является слабо типизированным языком. Это означает, что нет необходимости объявлять тип данных, который должна хранить переменная. Так, в пределах одной и той же области видимости переменная \$number может содержать как значение 2, так и строку " two " ("два"). В строго типизированных языках программирования, таких как С или Java, вы обязаны определить тип переменной , прежде чем присваивать ей значение, и, конечно, это значение должно быть указанного типа. Но это не означает, что в РНР нет понятия типа. Каждое значение, которое можно присвоить переменной, имеет свой тип.

Ниже представлены элементарные типы языка PHP:
\begin{itemize}
  \item Boolean - одно из двух значений true или false;
  \item Integer - целое число;
  \item Double - число с плавающей точкой;
  \item String - символьные данные(строка);
  \item Array - массив;
  \item Object - объект;
  \item Resource - дескриптор, используемый для идентификации и работы с внешними ресурсами , такими как базы данных или файлы; 
  \item Null - неинициализированное значение;
\end{itemize}


\subsubsection{Объектно-ориентированное программирование. }
\label{sub:practice:oop_php}
Ключевое слово class было зарезервировано ещё в третьей версии языка. В четвёртой версии стало возможно создавать классы и объекты на их основе. Однако принципы ООП поддерживались лишь частично, так например, все члены (переменные и методы) были открыты. К тому же создание объектов было дорогой операцией и работали они медленно.

Начиная с пятой версии PHP обладает полной поддержкой ООП. Работа с классами была оптимизирована и теперь такой код работает достаточно быстро.

Класс в PHP объявляется с помощью ключевого слова class. Методы и поля класса могут быть общедоступными (public, по умолчанию), защищёнными (protected) и скрытыми (private). PHP поддерживает все три основных механизма ООП - инкапсуляцию, полиморфизм подтипов и наследование (родительский класс указывается с помощью ключевого слова extends после имени класса). Поддерживаются интерфейсы (ставятся в соответствие с помощью implements). Разрешается объявление финальных, абстрактных методов и классов. Множественное наследование классов не поддерживается, однако класс может реализовывать несколько интерфейсов. Для обращения к методам родительского класса используется ключевое слово parent.

Начиная с версии 5.4.0 множественное наследование может быть реализовано с помощью механизма особенностей (англ. trait). Особенности похожи на примеси (англ. mixins), за исключением того что для них нельзя напрямую создать экземпляр. Повторное использование кода заключено в использовании кода особенности в нескольких классах. Допускается использовать в одном классе несколько особенностей. Механизм особенностей имеет средства разрешения конфликтов имён. При запуске программы код особенности будет «вкомпилирован» в код содержащего его класса.

Классы в PHP имеют ряд «магических» методов (англ. magic methods), начинающихся с двух символов подчёркивания. Особо стоит отметить конструктор (\_\_construct(), в версиях до 5.0 конструктором служил метод, одноимённый с классом) и деструктор (\_\_destruct()), а также методы чтения (\_\_get()) и записи (\_\_set()), свёртывания (\_\_sleep()) и развёртывания (\_\_wakeup()), клонирования (\_\_clone()) и др. Эти методы являются достаточно гибким инструментом: переопределяя их, можно добиться существенного изменения поведения объекта.

Все функции-члены реализованы виртуальными и потому все они являются методами.

Экземпляры класса создаются с помощью ключевого слова new, обращение к полям и методам объекта производится с использованием оператора ->. Для доступа к членам класса из его методов используется переменная \$this.

Пример объектно-ориентированной конструкции на языке PHP: 
\begin{lstlisting}
class C1 extends C2 implements I1, I2
{
  private $a;
  protected $b;

  function __construct($a, $b)
  {
    parent::__construct($a, $b);
    $this->a = $a;
    $this->b = $b;
  }

  public function plus()
  {
    return $this->a + $this->b;
  }
}

$d = new C1(1, 2);
echo $d->plus(); // 3
\end{lstlisting}

\subsubsection{Объектно-ориентированное программирование. }
\label{sub:practice:extebtions_php}
Интерпретатор состоит из ядра и подключаемых модулей, «расширений», представляющих собой динамические библиотеки. Расширения позволяют дополнить базовые возможности языка, предоставляя возможности для работы с базами данных, сокетами, динамической графикой, криптографическими библиотеками, документами формата PDF и тому подобным. Любой желающий может разработать своё собственное расширение и подключить его. Существует огромное количество расширений, как стандартных, так и созданных сторонними компаниями и энтузиастами, однако в стандартную поставку входит лишь несколько десятков хорошо зарекомендовавших себя. Множество расширений доступно в репозитории PECL.

Ниже представлены «расширения» языка использованные в этой дипломной работе:
\begin{itemize}
  \item mbstring - предоставляет функции для работы с многобайтными строками, которые облегчают работу c многобайтными кодировками в PHP. Кроме того, mbstring занимается конвертированием строк из одной кодировки в другую. mbstring предназначен для работы с Unicode-кодировками, такими, как UTF-8 и UCS-2, а также с многими однобайтными кодировками;
  \item xml - Данное расширение позволит вам создавать XML-анализаторы и далее определить обработчики для различных событий. Каждый XML-анализатор также имеет несколько параметров, которые вы можете настраивать. В работе требовалось для корректной работы с YAML файлами конфигураций платформы Symfony;
  \item pdo - определяет простой и согласованный интерфейс для доступа к базам данных в PHP;
\end{itemize}

\subsubsection{Режимы запуска интерпретатора. }
\label{sub:practice:extebtions_php}

SAPI - это внешний уровень абстракции, предназначенный для встраивания интерпретатора в другие приложения и отвечает за его работу (запуск, остановка, передача скриптов на исполнение, доступ к внешним данным). Существует несколько основных SAPI определяющих способы запуска и использования PHP:

\begin{itemize}
    \item   В качестве модуля к веб-серверу (например, для Apache модуль mod\_php). В этом случае интерпретатор PHP выполняется в окружении процесса веб-сервера. Веб-сервер управляет количеством запущенных процессов PHP и сообщает им какие скрипты требуется исполнить.

    \item   CGI SAPI. Использование CGI подразумевает запуск нового процесса для обработки каждого запроса. Для исполнения PHP скрипта веб-сервер запускает ./php-cgi /path/to/script.php. Сам принцип такого использования подразумевает, что интерпретатор PHP исполняет только один скрипт, после чего заканчивает свою работу. Затраты на запуск процесса интерпретатора и его инициализацию очень часто сопоставимы или даже превышают затраты на исполнение PHP скрипта. Для решения этой проблемы в CGI SAPI был введен режим FastCGI. В этом режиме PHP интерпретатор запускается как независимый сервер, обрабатывающий входящие запросы на исполнение PHP скриптов по протоколу FastCGI, что позволяет ему работать с любым веб-сервером поддерживающим этот протокол.

    \item   FPM SAPI, известный как php-fpm - это другая реализация протокола FastCGI. Создан изначально Андреем Нигматулиным как отдельный патч для использования в социальной сети Badoo. Данная реализация решала ряд проблем, которые мешали использованию CGI/FastCGI SAPI. В частности, появилась возможность перезапуска пула интерпретаторов PHP без потери запросов, запуск нескольких пулов под разными пользователями, аварийный перезапуск интерпретаторов в случае проблем с ними и ещё несколько приятных дополнений. В дальнейшем над патчем работали несколько человек, был добавлен режим динамического управления числом запущенных процессов PHP (по принципу управления числом процессов в веб-сервере Apache), и начиная с версии PHP 5.3.3 php-fpm был включен в PHP как отдельное SAPI.

    \item   В качестве скрипта командной строки (CLI SAPI), являющегося исполняемым файлом, который вызывается пользователем из командной строки; скрипт выполняется в окружении вызвавшего пользователя. В этом случае возможно использование PHP для создания клиентских GUI-приложений и решения административных задач в операционных системах UNIX, Linux, Microsoft Windows, Mac OS X и AmigaOS. Однако в таком качестве он не получил распространение, отдавая пальму первенства Perl, Python и VBScript.
    Начиная с версии PHP 5.4.0 в CLI SAPI появилась возможность запуска PHP как отдельного HTTP сервера. Однако этот режим предназначен исключительно для разработки, так как запускает только один процесс интерпретатора и выполняет все запросы исключительно последовательно.
\end{itemize}


\subsection{Платформа Symfony}
\label{sub:practice:symfony}

Symfony - свободная программная платформа, написанная на PHP, который использует паттерн Model-View-Controller.

Symfony предлагает быструю разработку и управление веб-приложениями, позволяет легко решать рутинные задачи веб-программиста. Работает только с PHP 5 и выше. Имеет поддержку множества баз данных (MySQL, PostgreSQL, SQLite или любая другая PDO-совместимая СУБД). Информация о реляционной базе данных в проекте должна быть связана с объектной моделью. Это можно сделать при помощи ORM инструмента. В Symfony это Doctrine.

Symfony бесплатен и публикуется под лицензией MIT.

\subsection{ORM Doctrine}
\label{sub:practice:doctrine}
Doctrine - объектно-реляционный проектор (ORM) для PHP 5, который базируется на слое абстракции доступа к БД (DBAL). Одной из ключевых возможностей Doctrine является запись запросов к БД на собственном объектно-ориентированном диалекте SQL, называемый DQL (Doctrine Query Language) и базирующийся на идеях HQL (Hibernate Query Language).

Doctrine cледует паттерну Data mapper. Для создания пользователя может использоватся следующий код:

\begin{lstlisting}
$user = new User();
$user->setName("john");
$user->setPassword("doe");
$entityManager->persist($user);
$entityManager->flush();
echo "The user with id " . $user->getId() . "has been saved.";
\end{lstlisting}


Получение оъекта класса Product соответствующего строке в базе данных по уникальному \$id:
\begin{lstlisting}
  $em = $this->getDoctrine();
  $product = $em->getRepository('AcmeStoreBundle:Product')->find($id);
\end{lstlisting}

Добавление оъекта класса Product с именем 'Name' в базу данных:
\begin{lstlisting}
  $product = new Product();
  $product->setName('Name');

  $em = $this->getDoctrine()->getManager();

  $em->persist($product);
  $em->flush();
\end{lstlisting}

Одной из особенностей Doctrine является низкий уровень конфигурации, необходимый для запуска проекта. Doctrine может генерировать классы объектов из существующей базы данных, и программист может затем указать отношения и добавить пользовательские функциональные возможности к сгенерированным классам. Нет необходимости создавать или поддерживать сложные схемы базы данных XML, как это видно во многих других платформах.

Еще одной важной особенностью Doctrine является возможность произвольной записи запросов базы данных в диалекте OO 
(объектно-ориентированный) SQL, называемом DQL (Doctrine Query Language), который был разработан на основе  HQL Hibernate. Класс QueryBuilder позволяет создавать запросы через свободный интерфесы. Эти интерфейсы предоставляют разработчикам мощные альтернативы SQL, которые поддерживают гибкость и позволяют переключать базы данных, не требуя дублирования кода.

Ниже представлен пример испольования QueryBuilder в Doctrine:
\begin{lstlisting}
$repository = $this->getDoctrine()->getRepository('...');

$query = $repository
            ->createQueryBuilder('p')
            ->where('p.price>:price')
            ->setParameter('price','19.99')
            ->orderBy('p.price','ASC')
            ->getQuery();

$products = $query->getResult();
\end{lstlisting}

Явное написание запросов к БД не всегда необходимо, так как Doctrine выполняет объединения и выбирает связанные объекты автоматически. Малые проекты можно построить не используя запросы.
